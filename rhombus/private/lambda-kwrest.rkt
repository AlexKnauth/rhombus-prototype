#lang racket/base
(require (for-syntax racket/base
                     syntax/parse/pre)
         racket/unsafe/undefined)

(provide lambda/kwrest
         case-lambda/kwrest)

;; ---------------------------------------------------------

(define-syntax lambda/kwrest
  (lambda (stx)
    (syntax-parse stx
      ;; This case is unused, because Racket `define` has to recognize
      ;; an immediate, unexpanded `lambda` in order to optimize
      ;; keyword arguments.
      #;
      [(_ #:name name
          #:arity _
          (~optional (~seq #:rest rest))
          (arg ...)
          b ...)
       #'(let ([name (lambda (~? (arg ... . rest)
                                 (arg ...))
                       b ...)])
           name)]
      [(_ #:name name
          #:arity arity
          (~optional (~seq #:rest rest))
          #:kwrest kwrest
          ;; assumption: default values are simple enough to be duplicated
          ((~alt (~seq kw:keyword (~or* [kw-arg kw-default] kw-arg))
                 (~or* [arg default] arg))
           ...)
          b ...)
       ;; assumption: optional by-position arguments must appear after
       ;; mandatory by-position arguments
       (define args (syntax->list #'(arg ...)))
       (define defaults (syntax->list #'((~? default) ...)))
       (define non-rest-max (length args))
       (define non-rest-min (- non-rest-max (length defaults)))
       (define-values (kwhash-proc-claws proc-claws)
         (for/lists (kwhash-proc-claws proc-claws)
                    ([n (in-inclusive-range non-rest-min non-rest-max)])
           (cond
             [(eqv? n non-rest-max)
              (values #`[(~? (kwrest #,@args . rest)
                             (kwrest #,@args))
                         (let*-values ([(kw-arg kwrest)
                                        ;; `unsafe-undefined` cannot be the result of a safe expression
                                        (~? (let ([val (hash-ref kwrest 'kw unsafe-undefined)])
                                              (if (eq? val unsafe-undefined)
                                                  (values kw-default kwrest)
                                                  (values val (hash-remove kwrest 'kw))))
                                            ;; guarded by reduced arity
                                            (values (hash-ref kwrest 'kw) (hash-remove kwrest 'kw)))]
                                       ...)
                           b ...)]
                      #`[(~? (#,@args . rest)
                             (#,@args))
                         (~? (apply kwhash-proc '#hashalw() #,@args rest)
                             (kwhash-proc '#hashalw() #,@args))])]
             [else
              (define given-args
                (for/list ([arg (in-list args)]
                           [_ (in-range n)])
                  arg))
              (define unsupplied-args
                (list-tail defaults (- n non-rest-min)))
              (values #`[(kwrest #,@given-args)
                         (kwhash-proc kwrest #,@given-args #,@unsupplied-args)]
                      #`[(#,@given-args)
                         (kwhash-proc '#hashalw() #,@given-args #,@unsupplied-args)])])))
       (make-procedure-reduce-keyword-arity-mask
        #`(letrec ([kwhash-proc (case-lambda #,@kwhash-proc-claws)])
            (make-keyword-procedure
             (lambda (ks vs . ps)
               (apply kwhash-proc (keyword-lists->hash ks vs) ps))
             (let ([name (case-lambda #,@proc-claws)])
               name)))
        #'arity)])))

(define-syntax case-lambda/kwrest
  (lambda (stx)
    (syntax-parse stx
      [(_ #:name name
          #:arity _
          [(~optional (~seq #:rest rest))
           (arg ...)
           b ...]
          ...)
       #'(let ([name (case-lambda
                       [(~? (arg ... . rest)
                            (arg ...))
                        b ...]
                       ...)])
           name)]
      ;; assumption: all clauses must accept `#:kwrest`
      ;; We don't do anything fancy here, because dispatch code is
      ;; generated by `fun` itself.
      [(_ #:name name
          #:arity arity
          [(~optional (~seq #:rest rest))
           #:kwrest kwrest
           (arg ...)
           b ...]
          ...)
       (make-procedure-reduce-keyword-arity-mask
        #'(let ([kwhash-proc (case-lambda
                               [(~? (kwrest arg ... . rest)
                                    (kwrest arg ...))
                                b ...]
                               ...)])
            (make-keyword-procedure
             (lambda (ks vs . ps)
               (apply kwhash-proc (keyword-lists->hash ks vs) ps))
             (let ([name (case-lambda
                           [(~? (arg ... . rest)
                                (arg ...))
                            (~? (apply kwhash-proc '#hashalw() arg ... rest)
                                (kwhash-proc '#hashalw() arg ...))]
                           ...)])
               name)))
        #'arity)])))

(define-for-syntax (make-procedure-reduce-keyword-arity-mask proc arity)
  (syntax-parse arity
    [(_ () #f) proc]
    [(mask required-kws allowed-kws)
     #`(procedure-reduce-keyword-arity-mask #,proc 'mask 'required-kws 'allowed-kws)]))

;; ---------------------------------------------------------

;; keyword-lists->hash : (Listof Keyword) (Listof V) -> (Hashof Keyword V)
(define (keyword-lists->hash ks vs)
  (for/hashalw ([k (in-list ks)]
                [v (in-list vs)])
    (values k v)))
