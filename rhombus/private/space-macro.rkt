#lang racket/base
(require (for-syntax racket/base
                     syntax/parse
                     "space-meta-macro.rkt"
                     "expose.rkt")
         "provide.rkt"
         "space-provide.rkt"
         "name-root.rkt"
         "declaration.rkt"
         "space.rkt"
         "parens.rkt"
         "parse.rkt"
         "macro-macro.rkt"
         "space-clause.rkt"
         "forwarding-sequence.rkt"
         (submod "space-clause-primitive.rkt" for-space-macro)
         (submod "namespace.rkt" for-exports))

(provide (for-syntax
          (for-spaces (rhombus/namespace
                       rhombus/space)
                      space_meta_clause)))

(define+provide-space space rhombus/space
  #:fields
  (enforest
   transform))

(define+provide-space space_clause rhombus/space_clause
  #:fields
  ())

(define-syntax enforest
  (declaration-transformer
    (lambda (stx)
      (syntax-parse stx
        #:datum-literals (group)
        [(_  name:identifier (_::block . clauses))
         (define data #`[#,stx base-stx #,(syntax-local-introduce #'scope-stx)
                         name enforest-meta define-operator-definition-transformer])
         #`((rhombus-mixed-nested-forwarding-sequence (enforest-finish #,data) rhombus-space-clause
                                                      (enforest-body-step . #,(syntax-local-introduce #'clauses))))]))))

(define-syntax transform
  (declaration-transformer
    (lambda (stx)
      (syntax-parse stx
        #:datum-literals (group)
        [(_  name:identifier (_::block . clauses))
         (define data #`[#,stx base-stx #,(syntax-local-introduce #'scope-stx)
                         name transform-meta define-identifier-syntax-definition-transformer*])
         #`((rhombus-mixed-nested-forwarding-sequence (enforest-finish #,data) rhombus-space-clause
                                                      (enforest-body-step . #,(syntax-local-introduce #'clauses))))]))))

(define-syntax enforest-body-step
  (lambda (stx)
    ;; parse the first form as a space clause, if possible, otherwise assume
    ;; an expression or definition
    (syntax-parse stx
      [(_ form . rest)
       #:with clause::space-clause (syntax-local-introduce #'form)
       (syntax-parse (syntax-local-introduce #'clause.parsed)
         #:datum-literals (group parsed)
         [((group (parsed p)) ...)
          #`(begin p ... (enforest-body-step . rest))]
         [(form ...)
          #`(enforest-body-step form ... . rest)])]
      [(_ form . rest)
       #`(rhombus-top-step
          enforest-body-step
          #f
          ()
          form . rest)]
      [(_) #'(begin)])))

(define-syntax enforest-finish
  (lambda (stx)
    (syntax-parse stx
      [(_ [orig-stx
           base-stx scope-stx
           name
           enforest-meta
           define-operator-definition-transformer]
          exports
          option
          ...)
       (define options (parse-space-clause-options #'orig-stx #'(option ...)))
       (define space-path-name (hash-ref options '#:space_path #f))
       (unless space-path-name
         (raise-syntax-error #f "space path must be declared" #'orig-stx))
       (define meta-namespace (hash-ref options '#:meta_namespace #f))
       (unless meta-namespace
         (raise-syntax-error #f "meta namespace must be declared" #'orig-stx))
       (define define-macro (hash-ref options '#:export_macro #f))
       (define exs (parse-exports #'(combine-out . exports)))
       (check-distinct-exports (exports->names exs) define-macro #'orig-stx)
       ;; The expansion here mostly sets up a bridge. The interesting
       ;; part is generated by `enforest-meta` at the end.
       #`(begin
           (define-space-syntax name
             (space-syntax #,space-path-name))
           (define-name-root name
             #:fields
             (#,@(filter-missing
                  #`([#,define-macro _define-macro]))
              . #,exs))
           (maybe-skip
            define-macro
            (define-operator-definition-transformer _define-macro
              'macro
              #,space-path-name
              #'make-prefix-operator
              #'make-infix-operator
              #'make-prefix+infix-operator))
           (begin-for-syntax
             (enforest-meta
              #,(car meta-namespace)
              [name base-stx scope-stx
                    #,space-path-name make-prefix-operator make-infix-operator make-prefix+infix-operator]
              #,(cdr meta-namespace))))])))

(define-syntax-rule (define-identifier-syntax-definition-transformer* name
                      _define-macro
                      protocol
                      space-path-name
                      make-prefix-operator
                      ignored-make-infix-operator
                      ignored-new-prefix+infix-operator)
  (define-identifier-syntax-definition-transformer _define-macro
    space-path-name
    make-prefix-operator))

(define-syntax (maybe-skip stx)
  (syntax-parse stx
    [(_ #f . _) #'(begin)]
    [(_ _ def) #'def]))

(define-for-syntax (filter-missing flds)
  (for/list ([fld (in-list (syntax->list flds))]
             #:when (syntax-parse fld
                      [[#f . _] #f]
                      [_ #t]))
    fld))

(define-for-syntax (check-distinct-exports ex-ht define-macro orig-stx)
  (when (and (syntax-e define-macro)
             (hash-ref ex-ht (syntax-e define-macro) #f))
    (raise-syntax-error #f
                        "exported name conflicts with macro definer name"
                        orig-stx
                        (hash-ref ex-ht (syntax-e define-macro) #f))))
