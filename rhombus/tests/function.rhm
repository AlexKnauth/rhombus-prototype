#lang rhombus

check:
  1 is_a Function ~is #false
  1 is_a Function.of_arity(1) ~is #false
  List is_a Function ~is #true
  List is_a Function.of_arity(1) ~is #true
  List is_a Function.of_arity(1, 2, 3) ~is #true
  Pair is_a Function.of_arity(2) ~is #true
  Pair is_a Function.of_arity(1, 2) ~is #false
  (fun (x): #void) is_a Function.of_arity(1) ~is #true
  (fun (x, ~y = 0): #void) is_a Function.of_arity(1) ~is #true
  (fun (x, ~y): #void) is_a Function.of_arity(1) ~is #false
  (fun (x, ~y = 0): #void) is_a Function.of_arity(1, ~y) ~is #true
  (fun (x, ~y): #void) is_a Function.of_arity(1, ~y) ~is #true

check:
  (fun (x): #void) is_a Function.of_arity(#void, error("I throw first!"))
  ~throws "I throw first!"

check:
  (fun (x): #void) is_a Function.of_arity(#false, 1)
  ~throws values("contract violation", "expected: NonnegInt")

check:
  (fun (x): x).map([1, 2, 3], [4, 5, 6])
  ~throws values(
    "argument mismatch",
    "the given function's expected number of arguments does not match the given number of lists",
    "expected", "1",
    "given", "2",
  )

check:
  (fun
   | (x): x
   | (x, y, z): x+y+z)
    .map([1, 2, 3], [4, 5, 6])
  ~throws values(
    "argument mismatch",
    "the given function's expected number of arguments does not match the given number of lists",
    "expected", "1 or 3",
    "given", "2",
  )

check:
  (fun
   | (x): x
   | (x, y, z): x+y+z
   | (x, y, z, w, q, _, ...): x*y*z*w*q)
    .map([1, 2, 3], [4, 5, 6])
  ~throws values(
    "argument mismatch",
    "the given function's expected number of arguments does not match the given number of lists",
    "expected", "1, 3, or at least 5",
    "given", "2",
  )

check:
  (fun (~kw, x, y): x+y).map([1, 2, 3], [4, 5, 6])
  ~throws values(
    "argument mismatch",
    "the given function expects keyword arguments",
    "required keywords", "~kw",
  )

check:
  (fun (~kw1, ~kw2, x, y): x+y).map([1, 2, 3], [4, 5, 6])
  ~throws values(
    "argument mismatch",
    "the given function expects keyword arguments",
    "required keywords", "~kw1 and ~kw2",
  )

check:
  (fun (~kw1, ~kw2, ~kw3, x, y): x+y).map([1, 2, 3], [4, 5, 6])
  ~throws values(
    "argument mismatch",
    "the given function expects keyword arguments",
    "required keywords", "~kw1, ~kw2, and ~kw3",
  )

block:
  fun take_all(~& _): #void
  check:
    take_all(~kw: #false,
             ~& {#'~kw: #false})
    ~throws "duplicate keyword in spliced map and direct keyword arguments"
  check:
    take_all(~& {#'~kw: #false},
             ~& {#'~kw: #false})
    ~throws "duplicate keyword in keyword-argument maps"
  check:
    take_all(~& {#'~kw: 1, #'~kw2: 2},
             ~& {#'~kw: 1, #'~kw3: 3, #'~kw4: 4})
    ~throws "duplicate keyword in keyword-argument maps"
  check:
    take_all(~& {#'~kw: 1, #'~kw3: 3, #'~kw4: 4},
             ~& {#'~kw: 1, #'~kw2: 2})
    ~throws "duplicate keyword in keyword-argument maps"
  check:
    take_all(~& MutableMap{#'~kw: 1, #'~kw2: 2})
    ~throws "not an immutable map for keyword arguments"
  check:
    take_all(~& MutableMap{#'~kw: 1, #'~kw2: 2},
             ~& MutableMap{#'~kw3: 3})
    ~throws "not an immutable map for keyword arguments"
