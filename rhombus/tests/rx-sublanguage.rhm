#lang rhombus/static/and_meta
import:
  lib("racket/base.rkt").pregexp

// an example use of `sublanguage.enforest`

export:
  rx
  any
  #{#%literal} #{#%comp} #{#%parens}
  || * ? ^ $
  names: #{#%juxtapose}

sublanguage.enforest example/rx:
  ~syntax_class Pattern
  ~macro macro
  ~only_macro only_macro
  ~macro_result: fun (stx, who):
                   unless (stx is_a Syntax
                             && (stx -: Syntax).unwrap() is_a String)
                   | Syntax.error("bad result", stx)
                   stx
  ~identifier_transformer: fun (id): no_identifier(id)
  ~desc "regexp"

expr.macro '«rx '$(pat :: Pattern)' $tail ...»':
  'pregexp($pat.parsed)'

macro 'any': '"."'

only_macro '#{#%literal} $(s :: String)':
  import lib("racket/base.rkt").#{regexp-quote}
  '$(#{regexp-quote}(s.unwrap()))'

only_macro '#{#%parens} ($(p :: Pattern))':
  p.parsed

only_macro '$left #{#%call} ($(p :: Pattern))':
  '$(left.unwrap() ++ p.parsed.unwrap())'

only_macro '$left || $(~parsed right)':
  ~weaker_than: ~other
  '$("(?:" +& left.unwrap() +& "|" +& right.unwrap() +& ")")'

only_macro '$left #{#%juxtapose} $(~parsed right)':
  ~weaker_than: ~other
  ~stronger_than: ||
  '$(left.unwrap() ++ right.unwrap())'

only_macro '$left *':
  '$(left.unwrap() ++ "*")'

only_macro '$left +':
  '$(left.unwrap() ++ "+")'

only_macro '$left ?':
  '$(left.unwrap() ++ "?")'

only_macro
| '$left #{#%comp} {$(min :: Integer), _}':
    '$(left.unwrap() ++ "{" +& min.unwrap() ++ ",}")'
| '$left #{#%comp} {$(min :: Integer), $(max :: Integer)}':
    '$(left.unwrap() ++ "{" +& min.unwrap() ++ "," +& max.unwrap() ++ "}")'
| '$left #{#%comp} {$(count :: Integer)}':
    '$(left.unwrap() ++ "{" +& count.unwrap() ++ "}")'

macro
| '^ $(~parsed right)':
    '$("^" +& right.unwrap())'

only_macro
| '$left $('$')':
    ~same_as: ^
    '$(left.unwrap() +& "$")'

meta:
  fun no_identifier(id):
    Syntax.error("no identifiers allowed", id)

check:
  rx'^ ("Hello" || "Hi") " "? ("Here"||"There") $'
  ~completes

check:
  rx'(^ "Hello" || "Hi"{1, 22} || "At("any*")") $'
  ~completes
