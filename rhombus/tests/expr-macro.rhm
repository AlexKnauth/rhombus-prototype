#lang rhombus/and_meta

// postfix as a macro "infix" operator;

fun
| factorial(0): 1
| factorial(n): n*factorial(n-1)

expr.macro '$a *!':
  '(factorial($a))'

check:
  10*!
  ~is 3628800

check:
  10*! + 1
  ~is 3628801


// a macro with an identifier name that does a weird
// thing with the result tail

expr.macro 'prefix_plus $a $b $c ...':
  values(a, '+ $b $c ...')

check:
  prefix_plus 7 9
  ~is 16

// another way to write that

expr.macro 'also_prefix_plus $e ...':
  match '$e ...'
  | '$a $b $c ...':
      values(a, '+ $b $c ...')
  | ~else:
      Syntax.error("bad syntax", '$e ...')

check:
  also_prefix_plus 7 9
  ~is 16

// an identifier macro

expr.macro 'just_five': '"five"'

check:
  just_five ++ " is the result"
  ~is "five is the result"

// mixin infix and prefix with multiple matching cases

macro
| 'weirdly coconut':
    ~stronger_than: +
    '"donut"'
| 'weirdly':
    '"banana"'
| '$a weirdly $b + $c':
    '$a + $b - $c'
| '$a weirdly $(b :: Term)':
    '$a + $b'

check:
  weirdly
  ~is "banana"
check:
  weirdly coconut
  ~is "donut"
check:
  weirdly coconut ++ "tree"
  ~is "donuttree"
check:
  weirdly ++ "none"
  ~is "banananone"
check:
  1 weirdly 5
  ~is 6
check:
  1 weirdly 5 + 7
  ~is -1
check:
  1 weirdly 5 * 7
  ~is 42

begin:
  expr.macro 'go ($(right :: expr_meta.AfterInfixGroup('*'): tail))':
    '$([tail, ...]
         +& '[$tail ...]'
         +& [right.tail, ...]
         +& '$right.tail ...')'
  check:
    go(3 + 4)
    ~is ("['+', '4']"
           +& "'[+ 4]'"
           +& "['+', '4']"
           +& "'+ 4'")

begin:
  expr.macro 'go ($(right :: expr_meta.AfterInfixGroup('*'): tail), ...)':
    '$([[tail, ...], ...]
         +& '[[$tail ...], ...]'
         +& [[right.tail, ...], ...]
         +& '[[$right.tail ...], ...]')'
  check:
    go(3 + 4, 5 + 8)
    ~is ("[['+', '4'], ['+', '8']]"
           +& "'[[+ 4], [+ 8]]'"
           +& "[['+', '4'], ['+', '8']]"
           +& "'[[+ 4], [+ 8]]'")


begin:
  expr.macro '$left ignored $tail ...':
    ~weaker_than: *
    ~stronger_than: +
    match '$tail ...'
    | '$(right :: expr_meta.AfterInfixGroup('ignored'))':
        values('$right.parsed',
               '$right.tail ...')

  check:
    5 ignored 2
    ~is 2
  check:
    5 ignored 2*2
    ~is 4
  check:
    5 ignored 2 + 3
    ~is 5

check:
  expr.macro 'quote $(x :: Group) $()': '('$x')'
  quote 1 + 2
  ~prints_like '1 + 2'

check:
  expr.macro 'quote $(x :: Group) $()': '($x)'
  quote 1 + 2
  ~is 3
